   1                     ; C Compiler for STM8 (COSMIC Software)
   2                     ; Parser V4.11.14 - 18 Nov 2019
   3                     ; Generator (Limited) V4.4.11 - 19 Nov 2019
   4                     ; Optimizer V4.4.11 - 19 Nov 2019
2562                     ; 44 void clock_init(void)
2562                     ; 45 {
2564                     	switch	.text
2565  e8e6               _clock_init:
2569                     ; 90 	CLK_ICKR = ((uint8_t)0x01);
2571  e8e6 350150c0      	mov	_CLK_ICKR,#1
2572                     ; 91 	CLK_ECKR = ((uint8_t)0x00);
2574  e8ea 725f50c1      	clr	_CLK_ECKR
2575                     ; 92 	CLK_SWR  = ((uint8_t)0xE1);
2577  e8ee 35e150c4      	mov	_CLK_SWR,#225
2578                     ; 93 	CLK_SWCR = ((uint8_t)0x00);
2580  e8f2 725f50c5      	clr	_CLK_SWCR
2581                     ; 94 	CLK_CKDIVR = ((uint8_t)0x18);
2583  e8f6 351850c6      	mov	_CLK_CKDIVR,#24
2584                     ; 95 	CLK_PCKENR1 = ((uint8_t)0xFF);
2586  e8fa 35ff50c7      	mov	_CLK_PCKENR1,#255
2587                     ; 96 	CLK_PCKENR2 = ((uint8_t)0xFF);
2589  e8fe 35ff50ca      	mov	_CLK_PCKENR2,#255
2590                     ; 97 	CLK_CSSR = ((uint8_t)0x00);
2592  e902 725f50c8      	clr	_CLK_CSSR
2593                     ; 98 	CLK_CCOR = ((uint8_t)0x00);
2595  e906 725f50c9      	clr	_CLK_CCOR
2597  e90a               L1461:
2598                     ; 99 	while ((CLK_CCOR & CLK_CCOR_CCOEN)!= 0) {}
2600  e90a 720050c9fb    	btjt	_CLK_CCOR,#0,L1461
2601                     ; 100 	CLK_CCOR = ((uint8_t)0x00);
2603  e90f 725f50c9      	clr	_CLK_CCOR
2604                     ; 101 	CLK_HSITRIMR = ((uint8_t)0x00);
2606  e913 725f50cc      	clr	_CLK_HSITRIMR
2607                     ; 102 	CLK_SWIMCCR = ((uint8_t)0x00);
2609  e917 725f50cd      	clr	_CLK_SWIMCCR
2610                     ; 105 	CLK_ICKR |= ((uint8_t)0x01); // Enable HSI oscillator (MAY NOT BE NECESSARY AFTER RESET)
2612  e91b 721050c0      	bset	_CLK_ICKR,#0
2614  e91f               L7461:
2615                     ; 108 	while ((CLK_ICKR & CLK_ICKR_HSIRDY)== 0) {}
2617  e91f 720350c0fb    	btjf	_CLK_ICKR,#1,L7461
2618                     ; 111 	CLK_SWCR |= CLK_SWCR_SWEN;
2620  e924 721250c5      	bset	_CLK_SWCR,#1
2621                     ; 117 	CLK_CKDIVR = (uint8_t)0x00;
2623  e928 725f50c6      	clr	_CLK_CKDIVR
2624                     ; 130 	CLK_PCKENR1 |= (uint8_t)0x80;		// Enable clock to TIM1
2626  e92c 721e50c7      	bset	_CLK_PCKENR1,#7
2627                     ; 131 	CLK_PCKENR1 |= (uint8_t)0x20;		// Enable clock to TIM2
2629  e930 721a50c7      	bset	_CLK_PCKENR1,#5
2630                     ; 132 	CLK_PCKENR1 |= (uint8_t)0x40;		// Enable clock to TIM3
2632  e934 721c50c7      	bset	_CLK_PCKENR1,#6
2633                     ; 133 	CLK_PCKENR1 &= (uint8_t)(~0x10);	// Disable clock to TIM4
2635  e938 721950c7      	bres	_CLK_PCKENR1,#4
2636                     ; 134 	CLK_PCKENR1 &= (uint8_t)(~0x08);	// Disable clock to UART
2638  e93c 721750c7      	bres	_CLK_PCKENR1,#3
2639                     ; 135 	CLK_PCKENR1 &= (uint8_t)(~0x02);	// Disable clock to SPI
2641  e940 721350c7      	bres	_CLK_PCKENR1,#1
2642                     ; 136 	CLK_PCKENR1 &= (uint8_t)(~0x01);	// Disable clock to I2C
2644  e944 721150c7      	bres	_CLK_PCKENR1,#0
2645                     ; 137 	CLK_PCKENR2 &= (uint8_t)(~0x08);	// Disable clock to ADC
2647  e948 721750ca      	bres	_CLK_PCKENR2,#3
2648                     ; 138 	CLK_PCKENR2 &= (uint8_t)(~0x04);	// Disable clock to AWU
2650  e94c 721550ca      	bres	_CLK_PCKENR2,#2
2651                     ; 156 	TIM2_PSCR = (uint8_t)0x0e;
2653  e950 350e530c      	mov	_TIM2_PSCR,#14
2654                     ; 158 	TIM2_CR1 = (uint8_t)0x01;
2656  e954 35015300      	mov	_TIM2_CR1,#1
2657                     ; 160 	TIM2_EGR = (uint8_t)0x01;
2659  e958 35015304      	mov	_TIM2_EGR,#1
2660                     ; 168 	TIM3_PSCR = (uint8_t)0x04;
2662  e95c 3504532a      	mov	_TIM3_PSCR,#4
2663                     ; 170 	TIM3_CR1 = (uint8_t)0x01;
2665  e960 35015320      	mov	_TIM3_CR1,#1
2666                     ; 172 	TIM3_EGR = (uint8_t)0x01;
2668  e964 35015324      	mov	_TIM3_EGR,#1
2669                     ; 174 	arp_timer = 0x00; // Initialize arp timer
2671  e968 725f0063      	clr	_arp_timer
2672                     ; 176 }
2675  e96c 81            	ret	
2703                     ; 190 periodic_timer_expired(void)
2703                     ; 191 {
2704                     	switch	.text
2705  e96d               _periodic_timer_expired:
2709                     ; 192   if ((uint8_t)TIM2_CNTRH > 1) { // For simplification evaluate at 512ms
2711  e96d c6530a        	ld	a,_TIM2_CNTRH
2712  e970 a102          	cp	a,#2
2713  e972 2517          	jrult	L3661
2714                     ; 193     TIM2_CR1 &= (uint8_t)(~0x01);	// Disable counter
2716  e974 72115300      	bres	_TIM2_CR1,#0
2717                     ; 194     TIM2_CNTRH = (uint8_t)0x00;		// Clear counter High
2719  e978 725f530a      	clr	_TIM2_CNTRH
2720                     ; 195     TIM2_CNTRL = (uint8_t)0x00;		// Clear counter Low
2722  e97c 725f530b      	clr	_TIM2_CNTRL
2723                     ; 196     TIM2_CR1 |= (uint8_t)0x01;		// Enable counter
2725  e980 72105300      	bset	_TIM2_CR1,#0
2726                     ; 197     arp_timer++;			// Increment arp_timer
2728  e984 725c0063      	inc	_arp_timer
2729                     ; 198     return(1);
2731  e988 a601          	ld	a,#1
2734  e98a 81            	ret	
2735  e98b               L3661:
2736                     ; 200   else return(0);
2738  e98b 4f            	clr	a
2741  e98c 81            	ret	
2765                     ; 211 arp_timer_expired(void)
2765                     ; 212 {
2766                     	switch	.text
2767  e98d               _arp_timer_expired:
2771                     ; 213   if (arp_timer > 19) {
2773  e98d c60063        	ld	a,_arp_timer
2774  e990 a114          	cp	a,#20
2775  e992 2507          	jrult	L7761
2776                     ; 214     arp_timer = 0;       // Reset arp_timer
2778  e994 725f0063      	clr	_arp_timer
2779                     ; 215     return(1);
2781  e998 a601          	ld	a,#1
2784  e99a 81            	ret	
2785  e99b               L7761:
2786                     ; 217   else return(0);
2788  e99b 4f            	clr	a
2791  e99c 81            	ret	
2833                     ; 233 wait_timer(uint16_t wait)
2833                     ; 234 {
2834                     	switch	.text
2835  e99d               _wait_timer:
2837  e99d 89            	pushw	x
2838  e99e 89            	pushw	x
2839       00000002      OFST:	set	2
2842                     ; 237   TIM3_CR1 &= (uint8_t)(~0x01);		// Disable counter
2844  e99f 72115320      	bres	_TIM3_CR1,#0
2845                     ; 238   TIM3_CNTRH = (uint8_t)0x00;		// Clear counter High
2847  e9a3 725f5328      	clr	_TIM3_CNTRH
2848                     ; 239   TIM3_CNTRL = (uint8_t)0x00;		// Clear counter Low
2850  e9a7 725f5329      	clr	_TIM3_CNTRL
2851                     ; 240   TIM3_CR1 |= (uint8_t)0x01;		// Enable counter
2853  e9ab 72105320      	bset	_TIM3_CR1,#0
2854  e9af               L1271:
2855                     ; 243     counter = ((uint16_t)TIM3_CNTRH << 8) | (uint8_t)TIM3_CNTRL;
2857  e9af c65328        	ld	a,_TIM3_CNTRH
2858  e9b2 97            	ld	xl,a
2859  e9b3 c65329        	ld	a,_TIM3_CNTRL
2860  e9b6 02            	rlwa	x,a
2861  e9b7 1f01          	ldw	(OFST-1,sp),x
2863                     ; 244   } while(counter <= wait);
2865  e9b9 1303          	cpw	x,(OFST+1,sp)
2866  e9bb 23f2          	jrule	L1271
2867                     ; 246   return;
2870  e9bd 5b04          	addw	sp,#4
2871  e9bf 81            	ret	
2893                     	xdef	_wait_timer
2894                     	xdef	_arp_timer_expired
2895                     	xdef	_periodic_timer_expired
2896                     	xdef	_clock_init
2897                     	switch	.bss
2898  0063               _arp_timer:
2899  0063 00            	ds.b	1
2900                     	xdef	_arp_timer
2920                     	end
