   1                     ; C Compiler for STM8 (COSMIC Software)
   2                     ; Parser V4.11.14 - 18 Nov 2019
   3                     ; Generator (Limited) V4.4.11 - 19 Nov 2019
   4                     ; Optimizer V4.4.11 - 19 Nov 2019
2562                     ; 44 void clock_init(void)
2562                     ; 45 {
2564                     	switch	.text
2565  e34b               _clock_init:
2569                     ; 90 	CLK_ICKR = ((uint8_t)0x01);
2571  e34b 350150c0      	mov	_CLK_ICKR,#1
2572                     ; 91 	CLK_ECKR = ((uint8_t)0x00);
2574  e34f 725f50c1      	clr	_CLK_ECKR
2575                     ; 92 	CLK_SWR  = ((uint8_t)0xE1);
2577  e353 35e150c4      	mov	_CLK_SWR,#225
2578                     ; 93 	CLK_SWCR = ((uint8_t)0x00);
2580  e357 725f50c5      	clr	_CLK_SWCR
2581                     ; 94 	CLK_CKDIVR = ((uint8_t)0x18);
2583  e35b 351850c6      	mov	_CLK_CKDIVR,#24
2584                     ; 95 	CLK_PCKENR1 = ((uint8_t)0xFF);
2586  e35f 35ff50c7      	mov	_CLK_PCKENR1,#255
2587                     ; 96 	CLK_PCKENR2 = ((uint8_t)0xFF);
2589  e363 35ff50ca      	mov	_CLK_PCKENR2,#255
2590                     ; 97 	CLK_CSSR = ((uint8_t)0x00);
2592  e367 725f50c8      	clr	_CLK_CSSR
2593                     ; 98 	CLK_CCOR = ((uint8_t)0x00);
2595  e36b 725f50c9      	clr	_CLK_CCOR
2597  e36f               L1461:
2598                     ; 99 	while ((CLK_CCOR & CLK_CCOR_CCOEN)!= 0) {}
2600  e36f 720050c9fb    	btjt	_CLK_CCOR,#0,L1461
2601                     ; 100 	CLK_CCOR = ((uint8_t)0x00);
2603  e374 725f50c9      	clr	_CLK_CCOR
2604                     ; 101 	CLK_HSITRIMR = ((uint8_t)0x00);
2606  e378 725f50cc      	clr	_CLK_HSITRIMR
2607                     ; 102 	CLK_SWIMCCR = ((uint8_t)0x00);
2609  e37c 725f50cd      	clr	_CLK_SWIMCCR
2610                     ; 105 	CLK_ICKR |= ((uint8_t)0x01); // Enable HSI oscillator (MAY NOT BE NECESSARY AFTER RESET)
2612  e380 721050c0      	bset	_CLK_ICKR,#0
2614  e384               L7461:
2615                     ; 108 	while ((CLK_ICKR & CLK_ICKR_HSIRDY)== 0) {}
2617  e384 720350c0fb    	btjf	_CLK_ICKR,#1,L7461
2618                     ; 111 	CLK_SWCR |= CLK_SWCR_SWEN;
2620  e389 721250c5      	bset	_CLK_SWCR,#1
2621                     ; 117 	CLK_CKDIVR = (uint8_t)0x00;
2623  e38d 725f50c6      	clr	_CLK_CKDIVR
2624                     ; 130 	CLK_PCKENR1 |= (uint8_t)0x80;		// Enable clock to TIM1
2626  e391 721e50c7      	bset	_CLK_PCKENR1,#7
2627                     ; 131 	CLK_PCKENR1 |= (uint8_t)0x20;		// Enable clock to TIM2
2629  e395 721a50c7      	bset	_CLK_PCKENR1,#5
2630                     ; 132 	CLK_PCKENR1 |= (uint8_t)0x40;		// Enable clock to TIM3
2632  e399 721c50c7      	bset	_CLK_PCKENR1,#6
2633                     ; 133 	CLK_PCKENR1 &= (uint8_t)(~0x10);	// Disable clock to TIM4
2635  e39d 721950c7      	bres	_CLK_PCKENR1,#4
2636                     ; 134 	CLK_PCKENR1 &= (uint8_t)(~0x08);	// Disable clock to UART
2638  e3a1 721750c7      	bres	_CLK_PCKENR1,#3
2639                     ; 135 	CLK_PCKENR1 &= (uint8_t)(~0x02);	// Disable clock to SPI
2641  e3a5 721350c7      	bres	_CLK_PCKENR1,#1
2642                     ; 136 	CLK_PCKENR1 &= (uint8_t)(~0x01);	// Disable clock to I2C
2644  e3a9 721150c7      	bres	_CLK_PCKENR1,#0
2645                     ; 137 	CLK_PCKENR2 &= (uint8_t)(~0x08);	// Disable clock to ADC
2647  e3ad 721750ca      	bres	_CLK_PCKENR2,#3
2648                     ; 138 	CLK_PCKENR2 &= (uint8_t)(~0x04);	// Disable clock to AWU
2650  e3b1 721550ca      	bres	_CLK_PCKENR2,#2
2651                     ; 156 	TIM2_PSCR = (uint8_t)0x0e;
2653  e3b5 350e530c      	mov	_TIM2_PSCR,#14
2654                     ; 158 	TIM2_CR1 = (uint8_t)0x01;
2656  e3b9 35015300      	mov	_TIM2_CR1,#1
2657                     ; 160 	TIM2_EGR = (uint8_t)0x01;
2659  e3bd 35015304      	mov	_TIM2_EGR,#1
2660                     ; 168 	TIM3_PSCR = (uint8_t)0x04;
2662  e3c1 3504532a      	mov	_TIM3_PSCR,#4
2663                     ; 170 	TIM3_CR1 = (uint8_t)0x01;
2665  e3c5 35015320      	mov	_TIM3_CR1,#1
2666                     ; 172 	TIM3_EGR = (uint8_t)0x01;
2668  e3c9 35015324      	mov	_TIM3_EGR,#1
2669                     ; 174 	arp_timer = 0x00; // Initialize arp timer
2671  e3cd 725f0063      	clr	_arp_timer
2672                     ; 176 }
2675  e3d1 81            	ret	
2703                     ; 190 periodic_timer_expired(void)
2703                     ; 191 {
2704                     	switch	.text
2705  e3d2               _periodic_timer_expired:
2709                     ; 192   if ((uint8_t)TIM2_CNTRH > 1) { // For simplification evaluate at 512ms
2711  e3d2 c6530a        	ld	a,_TIM2_CNTRH
2712  e3d5 a102          	cp	a,#2
2713  e3d7 2517          	jrult	L3661
2714                     ; 193     TIM2_CR1 &= (uint8_t)(~0x01);	// Disable counter
2716  e3d9 72115300      	bres	_TIM2_CR1,#0
2717                     ; 194     TIM2_CNTRH = (uint8_t)0x00;		// Clear counter High
2719  e3dd 725f530a      	clr	_TIM2_CNTRH
2720                     ; 195     TIM2_CNTRL = (uint8_t)0x00;		// Clear counter Low
2722  e3e1 725f530b      	clr	_TIM2_CNTRL
2723                     ; 196     TIM2_CR1 |= (uint8_t)0x01;		// Enable counter
2725  e3e5 72105300      	bset	_TIM2_CR1,#0
2726                     ; 197     arp_timer++;			// Increment arp_timer
2728  e3e9 725c0063      	inc	_arp_timer
2729                     ; 198     return(1);
2731  e3ed a601          	ld	a,#1
2734  e3ef 81            	ret	
2735  e3f0               L3661:
2736                     ; 200   else return(0);
2738  e3f0 4f            	clr	a
2741  e3f1 81            	ret	
2765                     ; 211 arp_timer_expired(void)
2765                     ; 212 {
2766                     	switch	.text
2767  e3f2               _arp_timer_expired:
2771                     ; 213   if (arp_timer > 19) {
2773  e3f2 c60063        	ld	a,_arp_timer
2774  e3f5 a114          	cp	a,#20
2775  e3f7 2507          	jrult	L7761
2776                     ; 214     arp_timer = 0;       // Reset arp_timer
2778  e3f9 725f0063      	clr	_arp_timer
2779                     ; 215     return(1);
2781  e3fd a601          	ld	a,#1
2784  e3ff 81            	ret	
2785  e400               L7761:
2786                     ; 217   else return(0);
2788  e400 4f            	clr	a
2791  e401 81            	ret	
2833                     ; 233 wait_timer(uint16_t wait)
2833                     ; 234 {
2834                     	switch	.text
2835  e402               _wait_timer:
2837  e402 89            	pushw	x
2838  e403 89            	pushw	x
2839       00000002      OFST:	set	2
2842                     ; 237   TIM3_CR1 &= (uint8_t)(~0x01);		// Disable counter
2844  e404 72115320      	bres	_TIM3_CR1,#0
2845                     ; 238   TIM3_CNTRH = (uint8_t)0x00;		// Clear counter High
2847  e408 725f5328      	clr	_TIM3_CNTRH
2848                     ; 239   TIM3_CNTRL = (uint8_t)0x00;		// Clear counter Low
2850  e40c 725f5329      	clr	_TIM3_CNTRL
2851                     ; 240   TIM3_CR1 |= (uint8_t)0x01;		// Enable counter
2853  e410 72105320      	bset	_TIM3_CR1,#0
2854  e414               L1271:
2855                     ; 243     counter = ((uint16_t)TIM3_CNTRH << 8) | (uint8_t)TIM3_CNTRL;
2857  e414 c65328        	ld	a,_TIM3_CNTRH
2858  e417 97            	ld	xl,a
2859  e418 c65329        	ld	a,_TIM3_CNTRL
2860  e41b 02            	rlwa	x,a
2861  e41c 1f01          	ldw	(OFST-1,sp),x
2863                     ; 244   } while(counter <= wait);
2865  e41e 1303          	cpw	x,(OFST+1,sp)
2866  e420 23f2          	jrule	L1271
2867                     ; 246   return;
2870  e422 5b04          	addw	sp,#4
2871  e424 81            	ret	
2893                     	xdef	_wait_timer
2894                     	xdef	_arp_timer_expired
2895                     	xdef	_periodic_timer_expired
2896                     	xdef	_clock_init
2897                     	switch	.bss
2898  0063               _arp_timer:
2899  0063 00            	ds.b	1
2900                     	xdef	_arp_timer
2920                     	end
